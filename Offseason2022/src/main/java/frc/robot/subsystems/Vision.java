
// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.commands.*;
import edu.wpi.first.math.filter.MedianFilter;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;

/**
 *
 */
public class Vision extends SubsystemBase
{

  double            targetHorizAngle;                   // Horizontal Offset from Crosshair to Target (-27 degrees to 27
                                                        // degrees)
  double            targetVertAngle;                    // Vertical Offset from Crosshair to Target (-20.5 degrees to
                                                        // 20.5 degrees)
  double            targetArea;                         // Target Area (0% of image to 100% of image)
  double            targetSkew;                         // Target Skew or rotation (-90 degrees to 0 degrees)
  boolean           targetValid;                        // Target Valid or not

  NetworkTableEntry modeEntry;
  NetworkTableEntry streamEntry;

  // variables in inches to calculate limelight distance
  double            slope;
  double            distOffset;
  double            distance1     = 48;
  double            distance2     = 60;
  double            vertOffset1   = 0.42;
  double            vertOffset2   = -4.85;

  double            distLight;

  // Creates a MedianFilter with a window size of 5 samples
  MedianFilter      yfilter       = new MedianFilter(5);

  NetworkTable      table;

  // Camera Limelight streaming
  private final int STANDARD      = 3;
  private final int PIP_MAIN      = 1;
  private final int PIP_SECONDARY = 2;

  // Limelight LED mode states
  private final int LED_CUR_MODE  = 0;
  private final int LED_OFF       = 1;
  private final int LED_BLINK     = 2;
  private final int LED_ON        = 3;

  /**
   *
   */
  public Vision( )
  {
    setName("Vision");
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    setSubsystem("Vision");

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    NetworkTableInstance inst = NetworkTableInstance.getDefault( );

    table = inst.getTable("limelight");
    SetLEDMode(LED_ON);
    SetCameraDisplay(PIP_SECONDARY);
    // Set camera and LED display

    SmartDashboard.setDefaultBoolean("VI_SOVERRIDE_ENABLED", false);

    // Variables declared above
    SmartDashboard.putNumber("VI_Distance1", distance1);
    SmartDashboard.putNumber("VI_Distance2", distance2);
    SmartDashboard.putNumber("VI_VertOffset1", vertOffset1);
    SmartDashboard.putNumber("VI_VertOffset2", vertOffset2);

  }

  double CalculateDist( )
  {
    slope = (distance2 - distance1) / (vertOffset2 - vertOffset1);
    distOffset = distance1 - slope * vertOffset1;
    distLight = (slope * targetVertAngle) + distOffset;

    return distLight;
  }

  @Override
  public void periodic( )
  {
    // This method will be called once per scheduler run
    boolean smOverrideEnabled = SmartDashboard.getBoolean("VI_SOVERRIDE_ENABLED", false);
    if (smOverrideEnabled)
    {
      // During daytime hours we can use smartdashboard to bipass the limelight.
      // This will allow us to calibrate the shooter distance without relying
      // on lighting conditions or limelight tuning.
      targetHorizAngle = SmartDashboard.getNumber("VI_SOVERRIDE_H_ANGLE", 0.0);
      targetVertAngle = SmartDashboard.getNumber("VI_SOVERRIDE_V_ANGLE", 0.0);
      targetArea = SmartDashboard.getNumber("VI_SOVERRIDE_TARGET_AREA", 0.0);
      targetSkew = SmartDashboard.getNumber("VI_SOVERRIDE_TARGET_SKEW", 0.0);
      targetValid = SmartDashboard.getBoolean("VI_SOVERRIDE_TARGET_VALID", true);
    }
    else
    {
      // How to access NetworkTable or get values from it? NetworkTablesEntry or NetworkTables?

      targetHorizAngle = table.getEntry("tx").getDouble(0.0);
      targetVertAngle = yfilter.calculate(table.getEntry("ty").getDouble(0.0));
      targetArea = table.getEntry("ta").getDouble(0.0);
      targetSkew = table.getEntry("ts").getDouble(0.0);
      // TODO: remove median filter during port to java
      targetValid = table.getEntry("tv").getBoolean(false);
    }

    CalculateDist( );

    SmartDashboard.putNumber("VI_HORIZ_ANGLE", targetHorizAngle);
    SmartDashboard.putNumber("VI_VERT_ANGLE", targetVertAngle);
    SmartDashboard.putNumber("VI_TARGET_AREA", targetArea);
    SmartDashboard.putNumber("VI_TARGET_SKEW", targetSkew);
    SmartDashboard.putBoolean("VI_TARGET_VALID", targetValid);
    SmartDashboard.putNumber("VI_Slope", slope);
    SmartDashboard.putNumber("VI_DistanceLimeLight", distLight);

  }

  void SyncStateFromDashboard( )
  {
    distance1 = SmartDashboard.getNumber("VI_Distance1", distance1);
    distance2 = SmartDashboard.getNumber("VI_Distance2", distance2);
    vertOffset1 = SmartDashboard.getNumber("VI_VertOffset1", vertOffset1);
    vertOffset2 = SmartDashboard.getNumber("VI_VertOffset2", vertOffset2);
  }

  @Override
  public void simulationPeriodic( )
  {
    // This method will be called once per scheduler run when in simulation
  }

  // Put methods for controlling this subsystem
  // here. Call these from Commands.
  double doubleGetHorizOffsetDeg( )
  {
    return targetHorizAngle;
  }

  double GetVertOffsetDeg( )
  {
    return targetVertAngle;
  }

  double GetTargetArea( )
  {
    return targetArea;
  }

  double GetTargetSkew( )
  {
    return targetSkew;
  }

  boolean GetTargetValid( )
  {
    return targetValid;
  }

  void SetLEDMode(int mode)
  {
    // TODO: find a putNumber replacer
    modeEntry = table.getEntry("ledMode");
    modeEntry.setValue(mode);
    // table.putNumber("ledMode", mode);

    // TODO: Replace with DataLogs
    // spdlog::info("VI SetLedMode : {}", mode);
  }

  int GetLEDMode( )
  {
    int mode = LED_CUR_MODE;
    // TODO: find a replacement for getInt for an int
    mode = (int) table.getEntry("ledMode").getNumber(0.0);

    // TODO: Replace with DataLogs
    // spdlog::info("VI GetLedMode : {}", mode);
    return mode;
  }

  void SetCameraDisplay(int stream)
  {
    streamEntry = table.getEntry("stream");
    modeEntry.setValue(stream);

    // TODO: Replace with DataLogs
    // spdlog::info("VI SetCameraDisplay : {}", stream);
  }

}
