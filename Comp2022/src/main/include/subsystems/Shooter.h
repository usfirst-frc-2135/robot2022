// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#pragma once
#include <frc/Encoder.h>
#include <frc/Solenoid.h>
#include <frc/filter/LinearFilter.h>
#include <frc/simulation/EncoderSim.h>
#include <frc/simulation/FlywheelSim.h>
#include <frc/system/plant/LinearSystemId.h>
#include <units/moment_of_inertia.h>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "ctre/Phoenix.h"

#include <frc2/command/SubsystemBase.h>

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

using namespace units::moment_of_inertia;

/**
 *
 *
 * @author ExampleAuthor
 */
class Shooter : public frc2::SubsystemBase
{
private:
    // It's desirable that everything possible is private except
    // for methods that implement subsystem capabilities

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    WPI_TalonFX m_motorSH11{ 11 };

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    const int kPidIndex = 0;    // PID index for primary sensor
    const int kSlotIndex = 0;   // PID slot index for sensors
    const int kCANTimeout = 10; // CAN timeout in msec to wait for response

    const double kFalconEncoderCPR = 2048; // CPR is 2048 from Falcon 500 Manual

    const double kFlywheelGearRatio = (18.0 / 12.0);
    const double kFlywheelCPR = kFalconEncoderCPR * kFlywheelGearRatio;

    // Declare module variables
    bool m_talonValidSH11; // Health indicator for shooter talon 11

    // Simulated flywheels - MOI is an estimate that seems to work for 2022 (not a calculated value)
    frc::LinearFilter<double> m_flywheelFilter = frc::LinearFilter<double>::SinglePoleIIR(0.1, 0.02_s);
    frc::sim::FlywheelSim m_flywheelSim{ frc::DCMotor::Falcon500(1), kFlywheelGearRatio, 0.02 * 1.0_kg_sq_m };

    // Configuration file parameters

    double m_flywheelPidKf;             // Flywheel PID force constant
    double m_flywheelPidKp;             // Flywheel PID proportional constant
    double m_flywheelPidKi;             // Flywheel PID integral constant
    double m_flywheelPidKd;             // Flywheel PID derivative constant
    double m_flywheelNeutralDeadband;   // Flywheel PID neutral deadband in percent
    double m_flywheelLowerHubTargetRPM; // Target flywheel RPM for shooting lower hub
    double m_flywheelUpperHubTargetRPM; // Target flywheel RPM for shooting upper hub

    // Measured RPM
    double m_flywheelCurrentRPM; // Current flywheel RPM

    double m_toleranceRPM; // Allowed variation from target RPM
    int m_state;           // Saved shooter state

    //Current limit settings
    SupplyCurrentLimitConfiguration m_supplyCurrentLimits = { true, 45.0, 45.0, 0.001 };
    StatorCurrentLimitConfiguration m_statorCurrentLimits = { true, 80.0, 80.0, 0.001 };

    // Conversion functions between RPM and Output and CTRE Native Units / 100ms
    double FlywheelRPMToNative(double rpm);
    double NativeToFlywheelRPM(double native);

public:
    Shooter();

    void Periodic() override;
    void SimulationPeriodic() override;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    typedef enum shooterSpeed_e
    {
        SHOOTERSPEED_REVERSE = -1, // Reverse shooter
        SHOOTERSPEED_STOP = 0,     // Stop shooter
        SHOOTERSPEED_LOWHUB = 1,   // Shooter Low Hub velocity
        SHOOTERSPEED_HIGHHUB = 2,  // Shooter High Hub velocity
        SHOOTERSPEED_PRIME = 3     // Shooter Priming velocity
    } shooterSpeed_e;

    void Initialize(void);
    void FaultDump(void);

    bool IsAtDesiredRPM();
    void SetShooterSpeed(int state);

    void ShooterReverseInit(void);
    void ShooterReverseExecute(void);
    void ShooterReverseEnd(void);
};
