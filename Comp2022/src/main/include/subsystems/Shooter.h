// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#pragma once
#include <frc/Encoder.h>
#include <frc/Solenoid.h>
#include <frc/filter/LinearFilter.h>
#include <frc/simulation/EncoderSim.h>
#include <frc/simulation/FlywheelSim.h>
#include <frc/system/plant/LinearSystemId.h>
#include <units/moment_of_inertia.h>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "ctre/Phoenix.h"

#include <frc2/command/SubsystemBase.h>

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

using namespace units::moment_of_inertia;

/**
 *
 *
 * @author ExampleAuthor
 */
class Shooter : public frc2::SubsystemBase
{
private:
    // It's desirable that everything possible is private except
    // for methods that implement subsystem capabilities

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    WPI_TalonFX m_motorSH11{ 11 };

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    frc::Solenoid m_flashlight{ 0, frc::PneumaticsModuleType::CTREPCM, 7 };

    frc::LinearFilter<double> m_flywheelFilter = frc::LinearFilter<double>::SinglePoleIIR(0.1, 0.02_s);

    // Sensors

    // Simulated flywheels
    frc::sim::FlywheelSim m_flywheelSim{
        frc::LinearSystemId::FlywheelSystem(frc::DCMotor::Falcon500(1), 1.0 * 1.0_kg_sq_m, 1.0),
        frc::DCMotor::Falcon500(1),
        1.5
    };

    const int kPidIndex = 0;    // PID index for primary sensor
    const int kSlotIndex = 0;   // PID slot index for sensors
    const int kCANTimeout = 10; // CAN timeout in msec to wait for response

    const double kFalconEncoderCPR = 2048; // CPR is 2048 from Falcon 500 Manual

    const double kFlywheelGearRatio = (12.0 / 18.0);
    const double kFlywheelCPR = kFalconEncoderCPR * kFlywheelGearRatio;

    // Declare module variables
    bool m_talonValidSH11; // Health indicator for shooter talon 11

    // Configuration file parameters

    double m_flywheelPidKf;           // Flywheel PID force constant
    double m_flywheelPidKp;           // Flywheel PID proportional constant
    double m_flywheelPidKi;           // Flywheel PID integral constant
    double m_flywheelPidKd;           // Flywheel PID derivative constant
    double m_flywheelNeutralDeadband; // Flywheel PID neutral deadband in percent
    double m_flywheelTargetRPM;       // Target flywheel RPM for shooting

    // Measured RPM
    double m_flywheelCurrentRPM; // Current flywheel RPM

    double m_toleranceRPM; // Allowed variation from target RPM
    int m_state;           // Saved shooter state

    // Conversion functions between RPM and Output and CTRE Native Units / 100ms
    double FlywheelRPMToNative(double rpm);
    double NativeToFlywheelRPM(double native);

public:
    Shooter();

    void Periodic() override;
    void SimulationPeriodic() override;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    typedef enum shooterSpeed_e
    {
        SHOOTERSPEED_STOP = 0,    // Stop shooter
        SHOOTERSPEED_FORWARD = 1, // Shooter velocity
    } shooterSpeed_e;

    void Initialize(void);
    void FaultDump(void);

    bool AtDesiredRPM();
    void SetShooterSpeed(int state);
    void FlashlightOn(bool onState);
};
